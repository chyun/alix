---
title: SHA1算法分析
description: >
  SHA1算法分析
layout: post
categories: 密码Hash
---

SHA1算法分析
=====================

1 SHA1算法简介 
安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。对于长度小于2^64位的消息， SHA1会产生一个160位的消息摘要。 当接收到消息的时候， 这个消息摘要可以用来验证数据的完整性。 在传输的过程中， 数据很可能会发生变化， 那么这时候就会产生不同的消息摘要。 
SHA1有如下特性： 

```
	1.不可以从消息摘要中复原信息；
	2.两个不同的消息不会产生同样的消息摘要(实际上是有可能的， 只是概率非常低， 实际应用中可以忽略)。
```

2 术语和概念 
---
2.1位(Bit)，字节（Byte）和字（Word） 

SHA1始终把消息当成一个位（bit）字符串来处理。本文中，一个“字”（Word）是32位，而一个“字节”（Byte）是8位。比如，字符串“abc”可以被转换成一个位字符串：01100001 01100010 01100011。它也可以被表示成16进制字符串: 0x616263. 

2.2 运算符和符号 

下面的逻辑运算符都被运用于“字”（Word） 
X^Y    = X， Y逻辑与 
X \/ Y   = X， Y逻辑或 
X XOR Y= X， Y逻辑异或 
~X     =   X逻辑取反 
X+Y定义如下： 
字 X 和 Y 代表两个整数 x 和y, 其中 0 <= x < 2^32 且 0 <= y < 2^32. 令整数z = (x + y) mod 2^32. 这时候 0 <= z < 2^32. 将z转换成字Z, 那么就是 Z = X + Y. 
循环左移位操作符Sn(X)。X是一个字，n是一个整数，0<=n<=32。Sn(X) = (X<<n)OR(X>>32-n) 
X<<n定义如下：抛弃最左边的n位数字，将各个位依次向左移动n位，然后用0填补右边的n位（最后结果还是32位）。X>>n是抛弃右边的n位，将各个位依次向右移动n位，然后在左边的n位填0。因此可以叫Sn(X)位循环移位运算 。

3 SHA1算法描述 
---
在SHA1算法中，我们必须把原始消息（字符串，文件等）转换成位字符串。SHA1算法只接受位作为输入。假设我们对字符串“abc”产生消息摘要。首先，我们将它转换成位字符串如下： 

```
	01100001 01100010 01100011 
	――――――――――――――――――――――――――
	‘a’=97   ‘b’=98   ‘c’=99 
```

这个位字符串的长度为24。下面我们需要5个步骤来计算MD5。 

3.1 补位 

消息必须进行补位，以使其长度在对512取模以后的余数是448。也就是说，（补位后的消息长度）%512 = 448。即使长度已经满足对512取模后余数是448，补位也必须要进行。  补位是这样进行的：先补一个1，然后再补0，直到长度满足对512取模后余数是448。总而言之，补位是至少补一位，最多补512位。还是以前面的“abc”为例显示补位的过程。 

```
	原始信息： 01100001 01100010 01100011 
	补位第一步：01100001 01100010 01100011 1                        首先补一个“1”
	补位第二步：01100001 01100010 01100011 10…..0                   然后补423个“0” 
	我们可以把最后补位完成后的数据用16进制写成下面的样子 
	61626380 00000000 00000000 00000000 
	00000000 00000000 00000000 00000000 
	00000000 00000000 00000000 00000000 
	00000000 00000000 
```

现在，数据的长度是448了，我们可以进行下一步操作。 

3.2 补长度 

所谓的补长度是将原始数据的长度补到已经进行了补位操作的消息后面。通常用一个64位的数据来表示原始消息的长度。如果消息长度不大于2^64，那么第一个字就是0。在进行了补长度的操作以后，整个消息就变成下面这样了（16进制格式） 

```
	61626380 00000000 00000000 00000000 
	00000000 00000000 00000000 00000000 
	00000000 00000000 00000000 00000000 
	00000000 00000000 00000000 00000018 
```

如果原始的消息长度超过了512，我们需要将它补成512的倍数。然后我们把整个消息分成一个一个512位的数据块，分别处理每一个数据块，从而得到消息摘要。 

3.3 使用的常量 

一系列的常量字K(0), K(1), ... , K(79)，如果以16进制给出。它们如下： 

```
	Kt = 0x5A827999   (0 <= t <= 19) 
	Kt = 0x6ED9EBA1 (20 <= t <= 39) 
	Kt = 0x8F1BBCDC (40 <= t <= 59) 
	Kt = 0xCA62C1D6 (60 <= t <= 79). 
```

3.4 需要使用的函数 

在SHA1中我们需要一系列的函数。每个函数ft (0 <= t <= 79)都操作32位字B，C，D并且产生32位字作为输出。

```
	ft(B,C,D)可以如下定义 
	ft(B,C,D) = (B AND C) or ((NOT B) AND D) ( 0 <= t <= 19) 
	ft(B,C,D) = B XOR C XOR D              (20 <= t <= 39) 
	ft(B,C,D) = (B AND C) or (B AND D) or (C AND D) (40 <= t <= 59) 
	ft(B,C,D) = B XOR C XOR D                     (60 <= t <= 79). 
```

3.5 计算消息摘要 

必须使用进行了补位和补长度后的消息来计算消息摘要。计算需要两个缓冲区，每个都由5个32位的字组成，还需要一个80个32位字的缓冲区。第一个5个字的缓冲区被标识为A，B，C，D，E。第一个5个字的缓冲区被标识为H0, H1, H2, H3, H4 
。80个字的缓冲区被标识为W0, W1,..., W79 

另外还需要一个一个字的TEMP缓冲区。 
为了产生消息摘要，在第4部分中定义的16个字的数据块M1, M2,..., Mn 
会依次进行处理，处理每个数据块Mi 包含80个步骤。 
在处理每个数据块之前，缓冲区{Hi} 被初始化为下面的值（16进制） ：

```
	H0 = 0x67452301 
	H1 = 0xEFCDAB89 
	H2 = 0x98BADCFE 
	H3 = 0x10325476 
	H4 = 0xC3D2E1F0. 
```

现在开始处理M1, M2, ... , Mn。为了处理 Mi,需要进行下面的步骤 

```
	(1). 将 Mi 分成 16 个字 W0, W1, ... , W15,   W0 是最左边的字 
	(2). 对于 t = 16 到 79 令 Wt = S1(Wt-3 XOR Wt-8 XOR Wt- 14 XOR Wt-16). 
	(3). 令 A = H0, B = H1, C = H2, D = H3, E = H4. 
	(4) 对于 t = 0 到 79，执行下面的循环 
    	TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt; 
    	E = D; D = C; C = S30(B); B = A; A = TEMP; 
	(5). 令 H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 
```

在处理完所有的 Mn, 后，消息摘要是一个160位的字符串，以下面的顺序标识

H0 H1 H2 H3 H4. 

对于SHA256,SHA384,SHA512。你也可以用相似的办法来计算消息摘要。对消息进行补位的算法完全是一样的。

JAVA中的SHA：
---
在 Java 中有提供有4种 SHA 算法的实现，相对 MD5(128 bit hash) 它提供了以下长度的 Hash：

	SHA-1 (简单实现 – 160 bits Hash)
	SHA-256 (强于 SHA-1 – 256 bits Hash)
	SHA-384 (强于 SHA-256 – 384 bits Hash)
	SHA-512 (强于 SHA-384 – 512 bits Hash)
通常越长的 Hash 越难破解，这是核心思想。

要获取相应算法实现，可通过参数的方式传给 MessageDigest 来获得实例。如下所示：

```
	MessageDigest md = MessageDigest.getInstance("SHA-1");
	//OR
	MessageDigest md = MessageDigest.getInstance("SHA-256");
```

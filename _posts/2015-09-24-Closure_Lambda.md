---
title: Closure, Lambda
description: >
  Closure, Lambda
layout: post
categories: Javascript
---

#闭包-从Lambda演算说起
以前看一些对Javascript闭包的解释, 总有一些不清楚的感觉, 前几天了解到闭包的理论基础是Lambda演算, 将闭包与Lambda演算结合起来, 才有一种拨开云雾的感觉.

#Lambda演算
函数式编程语言的基础是lambda演算，这是一套用于研究函数定义、应用和递归的形式系统，由数学家丘奇在20世纪30年代引入。

#Lambda演算的非形式化描述
在 lambda 演算中，每个表达式都代表一个只有单独参数的函数，这个函数的参数本身也是一个只有单一参数的函数，同时，函数的值是又一个只有单一参数的函数。函数是通过 lambda 表达式匿名地定义的，这个表达式说明了此函数将对其参数进行什么操作。

例如，“加 2”函数 f(x) = x + 2 可以用 lambda 演算表示为

	 λ x. x + 2 (或λ y. y + 2, 参数的取名无关紧要) 

而 f(3) 的值可以写作 (λ x. x + 2) 3。

有两个参数的函数可以通过 lambda 演算这么表达：一个单一参数的函数的返回值又是一个单一参数的函数 (参见 Currying)。例如, 函数 f(x, y) = x - y 可以写作
	
	λ x. λ y. x - y
	
将实参带入, 可得下述三个表达式是等价的:

	(λ x. λ y. x - y) 7 2
	(λ y. 7 - y) 2
	7 - 2

Note: 上述例子中的 +, -号都是非法的符号, 是为了举例子.

##Lambda演算的形式化描述

1.lambda演算系统中合法的字符如下:

	1. 标识符 (identifier)的可数无穷集合:{ x1, x2, x3, …}变元（变元的数量是无穷的，不能在有限步骤内穷举，这个很重要，后面有定理是根据这一点证明的)
	2. à 归约
	3. 等价
	4. λ, (, ) (辅助工具符号，一共有三个，λ和左括号右括号)

所有能够在lambda演算系统中出现的合法符号只有以上四种，其他符号都是非法的。例如λx.x+2, 如果没有其他对于＋符号的说明，那么这就是一个非法的λ演算表达式。

2.λ-项

λ-项在一些文章中也称为λ表达式（lambda expression), 它是由上面字母表中的合法字符组成的表达式，合法的表达式组成规则如下:
	a.任一个变元是一个项
	b.若M，N是项，则（MN）也是一个项  （function application，函数应用）
	c.若M是一个项，而x是一个变元，则（λx.M）也是一个项  （function abstraction，函数抽象）
	d.仅仅由以上规则归纳定义得到的符号串是项

因此, 所有的 lambda 表达式可以通过下述以 BNF 范式表达的上下文无关文法描述：

	<expr> ::= <identifier>
	<expr> ::= (λ <identifier> . <expr>)
	<expr> ::= (<expr> <expr>)
	
说明1:
	
	通常，lambda 抽象 (规则 2) 和函数作用 (规则 3) 中的括号在不会产生歧义的情况下可以省略。
	
如下假定保证了不会产生歧义：

	(1)函数的作用是左结合的。
 	(2)lambda 操作符被绑定到它后面的整个表达式

例如，表达式 ((λ x. (x x)) (λ y. y)) 可以简写成 (λ x. x x) λ y.y。

说明2:
	
	(λx.M)这样的λ-项被称为函数抽象，原因是它常常就是一个函数的定义，函数的参数就是变量x，函数体就是M，而函数名称则是匿名的。
	
用一个不恰当的比喻来说，我们通常认为的函数f(x)=x+2，可以被表达为λx.x+2。因为＋是未定义的，所以这个比喻只是为了方便理解而已。

说明3:
	
	MN这样的λ-项被称为函数应用，原因是它表达了将M这个函数应用到N这个概念。
	
沿用上面的例子f(x)=x+2，那么f(2)=2+2；同样的λx.x+2表达了f(x)的概念，那么（λx.x+2）2表达了f(2)的概念。其中M＝λx.x+2，N＝2，所以MN＝（λx.x+2）2。

注意说明3只是为了方便理解，但是还存在很多与直观理解不符合的地方。例如xy也是一个合法的λ-项，它们也是MN形式的，不过x和y都仅仅是一个变量而已，谈不上函数代入。

说明4:

	这里的另一难点就是要区分变量和元变量，如：M＝λx.x，这里x为变量，是我们在语法系统中定义了的，而M为元变量，没有在语法系统中定义，是我们用来表示的助记符。我们必须根据上下文来区分谁是变量，谁是元变量。

上面是λ-项的形式化定义，有一些是可以与函数理论直观联系的，而另一些只是说明这个λ-项是合法的，不一定有直观的字面意义.

3.λ-项中的变量自由出现法则

类似 λx.(xy) 这样的 lambda 表达式并未定义一个函数, 因为变量 y 的出现是自由的, 即它并没有被绑定到表达式中的任何一个 λ 上。在一个λ-项中, 变量要么是自由出现的,要么是被一个λ符号绑定的. 下面以函数的方式来理解变量的自由出现和绑定。例如f(x)=xy这个函数，我们知道x是和函数f相关的，因为它是f的形参，而y则是和f无关的。那么在λx.xy这个λ-项中，x就是被λ绑定的，而y则是自由出现的变量。

直观的理解，被绑定的变量就是作为某个函数形参的变量，而自由变量则是不作为任何函数形参的变量。

Lambda变量绑定规则：

	1.在表达式x中，如果x本身就是一个变量，那么x就是一个单独的自由出现。
	2.在表达式λx.E中，自由出现就是E中所有的除了x的自由出现。这种情况下在E中所有x的出现都称为被表达式中x前面的那个λ所绑定。
	3.在表达式(MN)中，变量的自由出现就是M和N中所有变量的自由出现。

关于Lambda演算, 这里只做简单介绍, 有兴趣的自行google.

#程序语言的闭包性质
假如, 我们用JavaScript定义了一个函数:

	function f(x){ return function(y) { return x + y; }; }
	
如果我们运行下面程序:

	f(7)

可以得到如下结果:

	function(y) { return x + y; }
	
可以看到, 其实在f(7)之后，f这个函数就结束了, 返回了一个匿名函数. 而x在返回的函数中是自由出现的. 
 
再运行下面的程序:

	f(7)(2)
	
可以得到如下结果:

	9

此处分析一下结果: 由于x（这里被赋值为7）是f的私有变量()绑定于f, 当f(7)运行之后, 函数f就已经结束了. 此时, 程序设计语言的设计者就有两种选择:

	第一, 在函数超出其作用域后立即销毁其绑定变量, 如果是这样的话，(f 7) (2) 是无法得出结果的，因为在外层的f运算结束后，存放数值“7”的变量就被释放了，所以匿名函数无法得到其自由变量x的值
	第二, 如果一个函数返回另一个函数, 而被返回函数又需要外层函数的变量时, 不会立即释放这个变量, 而是允许被返回的函数引用这些变量. 支持这种机制的语言称为支持闭包机制, 而这个内部函数连同其自由变量就形成了一个闭包。
	
显然Javascript的设计者采用了第二种选择.
